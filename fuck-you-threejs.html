<!doctype html>
<html>
<head>
    <title>Tectonics.js - 3d plate tectonics in your web browser</title>
    <!--If using any IE, don't even bother-->
    <!--[if IE]>
        <meta http-equiv="refresh" content="0;url=ie.html" />
    <![endif]-->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <link rel="icon" type="text/css" href="blog/icon6.png">
    <link rel="stylesheet" href="styles/bootstrap.min.css">
    <link rel="stylesheet" href="styles/main.css"/>
    <link rel="stylesheet" href="styles/app.css"/>

    <script src="libraries/vue.js"></script>
    <script src="libraries/Chart.js"></script>
    <script src="libraries/vue-charts.js"></script>
    <script src="libraries/bootstrap.bundle.min.js"></script>
    <script src="libraries/random-0.26.js"></script>
    <script src="libraries/base64-arraybuffer.js"></script>
    <script src="libraries/three.js/Three.js"></script>
    <script src="postcompiled/Shaders.js"></script>
    <script src="postcompiled/Rasters.js"></script>
    <script src="noncompiled/Units.js"></script>
    <script src="noncompiled/Interpolation.js"></script>
    <script src="noncompiled/Logging.js"></script>
    <!-- NOTE: we include scripts from the academic layer because it deals exclusively with rasters -->
    <script src="noncompiled/academics/SphericalGeometry.js"></script>
    <script src="noncompiled/academics/Optics.js"></script>
    <script src="noncompiled/academics/Thermodynamics.js"></script>
    <script src="noncompiled/academics/FluidMechanics.js"></script>
    <script src="noncompiled/academics/OrbitalMechanics.js"></script>
    <script src="noncompiled/academics/Tectonophysics.js"></script>
    <script src="noncompiled/academics/Hydrology.js"></script>
    <script src="noncompiled/academics/PlantBiology.js"></script>
    <script src="noncompiled/file-io/JsonSerializer.js"></script>
    <script src="noncompiled/controls/ControllerMotions.js"></script>
    <script src="noncompiled/controls/OrbitalControls.js"></script>
    <script src="noncompiled/controls/OrbitalController.js"></script>
    <script src="noncompiled/views/View.js"></script>
    <script src="noncompiled/views/ViewState.js"></script>
    <script src="noncompiled/views/scalar-rasters/ColorscaleRasterViewResources.js"></script>
    <script src="noncompiled/views/vector-rasters/VectorRasterViewResources.js"></script>
</head>
<body>
<!-- WebGL container -->
<canvas id="gl" style="display: block; width: 100vw; height: 100vh"></canvas>

<script type="text/javascript">
    'use strict';

    // get WebGL context
    if( !window.WebGLRenderingContext ){ process.exit(1); }
    const gl_tag = document.getElementById("gl");
    const gl = gl_tag.getContext("webgl");
    if (!gl) { process.exit(1); }

    const RenderPassType = {
        Background: 'background',
        Solids: 'solids',
        Volumetrics: 'volumetrics',
        LensEffects: 'lens_effects'
    };
    const ProjectionType = {
        Perspective: 0,
        Equirectangular: 1,
    };

    // practices RAII to minimize internal state
    // only two internal states exist: created and disposed
    // the disposed state can be entered at any time
    // methods in the disposed state will continue to produce valid behavior,
    // however the disposed state cannot be exited
    // the disposed state must be entered at some point prior to falling out of scope
    function DemoProgram(gl, initial_view_state) {
        // SHADERS
        const vertex_shader_source = `
            uniform   mat4  model_matrix;
            uniform   mat4  view_matrix;
            uniform   mat4  projection_matrix;
            uniform   int   projection_type;
            uniform   float map_projection_offset;
            attribute vec4  vertex_position;
            attribute float vertex_color_value;
            varying   float fragment_color_value;

            vec4 get_default_clipspace_position (
                in  vec4  local_position,
                in  mat4  model_matrix,
                in  mat4  view_matrix,
                in  mat4  projection_matrix,
                in  int   projection_type,
                in  float map_projection_offset
            ) {
                const float PI = 3.14159265358979;
                if (projection_type == 0)
                {
                    return projection_matrix * view_matrix * model_matrix * local_position;
                } 
                else if (projection_type == 1)
                {
                    vec4 model_position = model_matrix * local_position;
                    vec4 view_position = view_matrix[3];
                    float focus = atan(-view_position.z, view_position.x) + PI + map_projection_offset;
                    float lon_focused = mod(atan(-model_position.z, model_position.x) + PI - focus, 2.*PI) - PI;
                    float lat_focused = asin(model_position.y / length(model_position)); //+ (map_projection_offset*PI);
                    bool is_on_edge = lon_focused >  PI*0.9 || lon_focused < -PI*0.9;
                    vec4 projected_position = vec4(
                        lon_focused, lat_focused, is_on_edge? 0.0 : length(model_position), 1
                    );
                    mat4 scale_matrix = mat4(1);
                    scale_matrix[3] = view_matrix[3];
                    return projection_matrix * scale_matrix * projected_position;
                }
            }

            void main(){
                fragment_color_value = vertex_color_value;
                gl_Position = get_default_clipspace_position(
                    vertex_position, model_matrix, view_matrix, 
                    projection_matrix, projection_type, map_projection_offset
                );
            }`;
        const vertex_shader_object = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertex_shader_object, vertex_shader_source);
        gl.compileShader(vertex_shader_object);
        console.log(gl.getShaderInfoLog(vertex_shader_object));

        const fragment_shader_source = `
            precision mediump float;
            varying float fragment_color_value;
            /*
            converts float from 0-1 to a heat map visualization
            credit goes to GaÃ«tan Renaudeau: http://greweb.me/glsl.js/examples/heatmap/
            */
            vec3 get_rgb_signal_of_fraction_for_heatmap (float v) {
                float value = 1.0-v;
                return (0.5+0.5*smoothstep(0.0, 0.1, value))*vec3(
                    smoothstep(0.5, 0.3, value),
                    value < 0.3 ? smoothstep(0.0, 0.3, value) : smoothstep(1.0, 0.6, value),
                    smoothstep(0.4, 0.6, value)
                );
            }
            void main() {
                gl_FragColor = vec4(
                    get_rgb_signal_of_fraction_for_heatmap(fragment_color_value), 1
                );
            }`;
        const fragment_shader_object = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragment_shader_object, fragment_shader_source);
        gl.compileShader(fragment_shader_object);
        console.log(gl.getShaderInfoLog(fragment_shader_object));

        // PROGRAM
        const program = gl.createProgram();
        gl.attachShader(program, vertex_shader_object);
        gl.attachShader(program, fragment_shader_object);
        gl.linkProgram(program);
        console.log(gl.getProgramInfoLog(program));

        // UNIFORMS
        const view_matrix_location = gl.getUniformLocation(program, "view_matrix");
        const model_matrix_location = gl.getUniformLocation(program, "model_matrix");
        const projection_matrix_location = gl.getUniformLocation(program, "projection_matrix");
        const projection_type_location = gl.getUniformLocation(program, "projection_type");

        // ATTRIBUTES
        // properties shared by all buffers within the program
        const normalize = false; // don't normalize the data
        const stride = 0;        // 0: advance size*sizeof(type) each iteration to get the next position
        const offset = 0;        // 0: start at the beginning of the buffer

        const position_location = gl.getAttribLocation(program, "vertex_position");
        const position_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, position_buffer);
        gl.enableVertexAttribArray(position_location);
        gl.vertexAttribPointer(position_location, 3, gl.FLOAT, normalize, stride, offset);

        const color_value_location = gl.getAttribLocation(program, "vertex_color_value");
        const color_value_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, color_value_buffer);
        gl.enableVertexAttribArray(color_value_location);
        gl.vertexAttribPointer(color_value_location, 1, gl.FLOAT, normalize, stride, offset);
        
        let internal_view_state = Object.assign({}, initial_view_state);
        let is_disposed = false;

        // METHODS
        this.dispose = function() {
            is_disposed = true;
            gl.deleteBuffer(color_value_buffer);
            gl.deleteBuffer(position_buffer);
            gl.deleteProgram(program);
            gl.deleteShader(fragment_shader_object);
            gl.deleteShader(vertex_shader_object);
        }
        /*
        Returns whether this instance can fully depict a model using the given
        view state upon calling `.draw()`.
        If it cannot, the view state should be used to create a new instance, 
        and the old instance should be disposed before falling out of scope.
        This is not a test for whether the WebGL context or the view state 
        is well formatted. It is strictly a test of the program's private state.

        This demonstrates our approach to handling WebGL state management.
        If changing something is trivial, like uniforms or attributes, 
        we simply change it during the draw call without disposing resources.
        If changing something requires managing highly intertwined private 
        resources like shaders or programs, we simply wipe the slate clean
        on the first sign that anything falls out of sync.
        */
        this.canDepict = function(view_state) {
            return (!is_disposed);
        }
        /*
        Adds a depiction of a given model to the framebuffer that is currently 
        bound to the program's context using options from a given view state
        */
        this.draw = function(model_state, view_state) {
            if (is_disposed) { return; }

            // first shader pass
            if(view_state.render_pass_type === RenderPassType.Solids) {
                const array_offset = 0;
                gl.useProgram(program); 
                gl.uniform1i(projection_type_location, view_state.projection_type);
                gl.uniformMatrix4fv(view_matrix_location, false, view_state.view_matrix);
                gl.uniformMatrix4fv(model_matrix_location, false, view_state.model_matrix);
                gl.uniformMatrix4fv(projection_matrix_location, false, view_state.projection_matrix);
                gl.bindBuffer(gl.ARRAY_BUFFER, position_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, model_state.positions, gl.DYNAMIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, color_value_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, model_state.color_values, gl.DYNAMIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, array_offset, /*count*/ model_state.positions.length / 3);
            }
        }
    }








    const grid = new Grid(new THREE.IcosahedronGeometry(1, 5));
    var random = new Random();
    var demo = SphericalGeometry.get_random_surface_field(grid, random);

    const control_state = OrbitalControls.State({
        min_zoom_distance: 1.0,
        height: 5.0,
        angular_position: Vector2(0,Math.PI*30/180),
    });
    const view_state = {
        render_pass_type: RenderPassType.Solids,
        model_matrix: Matrix4x4.identity(),
        view_matrix: OrbitalControls.State.get_view_matrix(control_state),
        projection_matrix: 
            Matrix4x4.from_perspective(
                Math.PI*45/180, 
                gl.canvas.clientWidth/gl.canvas.clientHeight, 
                1e-3, 1e16
            ),
        projection_type: ProjectionType.Perspective,
    };
    const controls = new OrbitalController(
        control_state, 
        view_state.view_matrix,
        view_state.model_matrix
    );
    controls.addToDomElement(gl_tag);



    gl.canvas.width = gl.canvas.clientWidth;
    gl.canvas.height = gl.canvas.clientHeight;
    gl.viewport(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);


    let demo_program = new DemoProgram(gl, view_state);
    const face_corner_color_values_storage = new Float32Array(grid._buffer_geometry_positions.length);

    // animation loop
    function animate() {
        // push to render queue and loop
        // - it has to be at the begining of the function
        // - to learn more: https://www.youtube.com/watch?v=8aGhZQkoFbQ
        requestAnimationFrame( animate );

        if (gl.canvas.width !== gl.canvas.clientWidth || gl.canvas.height !== gl.canvas.clientHeight) {
            gl.canvas.width = gl.canvas.clientWidth;
            gl.canvas.height = gl.canvas.clientHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            view_state.projection_matrix = Matrix4x4.from_perspective(
                Math.PI*45/180, 
                gl.canvas.clientWidth/gl.canvas.clientHeight, 
                1e-5, 1e16
            );
        }

        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        if (!demo_program.canDepict(view_state)) {
            demo_program.dispose();
            demo_program = new DemoProgram(gl, view_state);
        }
        Float32Raster.get_ids(demo, demo.grid.buffer_array_to_cell, face_corner_color_values_storage); 
        demo_program.draw(
            { 
                positions: grid._buffer_geometry_positions, 
                color_values: face_corner_color_values_storage
            }, 
            view_state,
        );
    }

    animate();
</script>
</body>
</html>
