const float BIG = 1e20;
const float SMALL = 1e-20;

// "get_height_along_ray_over_world" gets the height at a point along the path
//   for a ray traveling over a world.
// NOTE: all input distances are relative to closest approach!
float get_height_along_ray_over_world(float x, float z2, float R){
    return sqrt(max(x*x + z2, 0.)) - R;
}
// "get_height_change_rate_along_ray_over_world" gets the rate at which height changes for a distance traveled along the path
//   for a ray traveling through the atmosphere.
// NOTE: all input distances are relative to closest approach!
float get_height_change_rate_along_ray_over_world(float x, float z2){
    return x / sqrt(max(x*x + z2, 0.));
}
// "get_air_density_ratio_at_height" gets the density ratio of an height within the atmosphere
// the "density ratio" is density expressed as a fraction of a surface value
float get_air_density_ratio_at_height(
    float h, 
    float H
){
    return exp(-h/H);
}
// "approx_air_column_density_ratio_along_ray_from_samples" returns an approximation 
//   for the columnar density ratio encountered by a ray traveling through the atmosphere.
// It is the integral of get_air_density_ratio_at_height() along the path of the ray, 
//   taking into account the height at every point along the path.
// We can't solve the integral in the usual fashion due to singularities
//   (see https://www.wolframalpha.com/input/?i=integrate+exp(-sqrt(x%5E2%2Bz%5E2)%2FH)+dx)
//   so we use a linear approximation for the height.
// Our linear approximation gets its slope and intercept from sampling
//   at points along the path (xm and xb respectively)
// NOTE: all input distances are relative to closest approach!
float approx_air_column_density_ratio_along_ray_from_samples(float x, float xm, float xb, float z2, float R, float H){
	float m = get_height_change_rate_along_ray_over_world(xm,z2);
	float b = get_height_along_ray_over_world(xb,z2,R);
	float h = m*(x-xb) + b;
    return -H/m * exp(-h/H);
}
// "approx_air_column_density_ratio_along_ray_for_segment" is a convenience wrapper for approx_air_column_density_ratio_along_ray_from_samples(), 
//   which calculates sensible values of xm and xb for the user 
//   given a specified range around which the approximation must be valid.
// The range is indicated by its lower bounds (xmin) and width (dx).
// NOTE: all input distances are relative to closest approach!
float approx_air_column_density_ratio_along_ray_for_segment(float x, float xmin, float dx, float z2, float R, float H){
    const float fm = 0.5;
    const float fb = 0.2;

    float xm   = xmin + fm*dx;
    float xb   = xmin + fb*dx;
    float xmax = xmin +    dx;

    return approx_air_column_density_ratio_along_ray_from_samples(clamp(x, xmin, xmax), xm, xb, z2,R,H);
}
// "approx_air_column_density_ratio_along_ray_for_absx" is a convenience wrapper for approx_air_column_density_ratio_along_ray_for_segment().
// It returns an approximation of columnar density ratio encountered from 
//   the surface of a world to a given upper bound, "x"
// Unlike approx_air_column_density_ratio_along_ray_from_samples() and approx_air_column_density_ratio_along_ray_for_segment(), 
//   it should be appropriate for any value of x, no matter if it's positive or negative.
// It does this by making two linear approximations for height:
//   one for the lower atmosphere, one for the upper atmosphere.
// These are represented by the two call outs to approx_air_column_density_ratio_along_ray_for_segment().
// "x" is the distance along the ray from closest approach to the upper bound (always positive),
//   or from the closest approach to the upper bound, if there is no intersection.
// "x_atmo" is the distance along the ray from closest approach to the top of the atmosphere (always positive)
// "x_world" is the distance along the ray from closest approach to the surface of the world (always positive)
// "sigma0" is the columnar density ratio generated by this equation when x is on the surface of the world;
//   it is used to express values for columnar density ratio relative to the surface of the world.
// "z2" is the closest distance from the ray to the center of the world, squared.
// NOTE: all input distances are relative to closest approach!
float approx_air_column_density_ratio_along_ray_for_absx(float x, float x_world, float x_atmo, float sigma0, float z2, float R, float H){
    // sanitize x_world so it's always positive
    x_world = abs(x_world);
    // sanitize x_atmo so it's always positive
    x_atmo  = abs(x_atmo);
    // sanitize x so it's always positive and greater than x_world
    x = max(abs(x)-x_world, 0.) + x_world;
    // "dx" is the width of the bounds covered by our linear approximations
    float dx = (x_atmo-x_world)/3.;

    return
        approx_air_column_density_ratio_along_ray_for_segment(x, x_world,    dx, z2,R,H)
      + approx_air_column_density_ratio_along_ray_for_segment(x, x_world+dx, dx, z2,R,H)
      - sigma0;
}
// "approx_reference_air_column_density_ratio_along_ray" is a convenience wrapper for approx_air_column_density_ratio_along_ray_for_absx().
// It returns a reference value that can be passed to approx_air_column_density_ratio_along_ray_2d().
// NOTE: all input distances are relative to closest approach!
float approx_reference_air_column_density_ratio_along_ray(float x_world, float x_atmo, float z2, float R, float H){
    return approx_air_column_density_ratio_along_ray_for_absx(x_world, x_world, x_atmo, 0., z2, R, H);
}
// "approx_air_column_density_ratio_along_ray_2d" is a convenience wrapper for approx_air_column_density_ratio_along_ray_for_absx().
// It returns a approximation of columnar density ratio that should be appropriate for any value of x.
// NOTE: all input distances are relative to closest approach!
float approx_air_column_density_ratio_along_ray_2d (float x_start, float x_stop, float x_world, float x_atmo, float sigma0, float z2, float R, float H){
    // NOTE: we clamp the result to prevent the generation of inifinities and nans, 
    // which can cause graphical artifacts.
    return 
        sign(x_stop)  * min(approx_air_column_density_ratio_along_ray_for_absx(x_stop,  x_world, x_atmo, sigma0, z2, R, H), BIG) -
    	sign(x_start) * min(approx_air_column_density_ratio_along_ray_for_absx(x_start, x_world, x_atmo, sigma0, z2, R, H), BIG); 
}
// "try_approx_air_column_density_ratio_along_ray" is an all-in-one convenience wrapper 
//   for approx_air_column_density_ratio_along_ray_2d() and approx_reference_air_column_density_ratio_along_ray.
// Just pass it the origin and direction of a 3d ray and it will find the column density ratio along its path, 
//   or return false to indicate the ray passes through the surface of the world.
float approx_air_column_density_ratio_along_line_segment (
	vec3  segment_origin, 
    vec3  segment_direction,
    float segment_length,
	vec3  world_position, 
	float world_radius, 
	float atmosphere_scale_height
){

    float z2;  					// distance ("radius") from the ray to the center of the world at closest approach, squared
    float x_z; 					// distance from the origin at which closest approach occurs

    float x_enter_atmo;  		// distance from the origin at which the ray enters the atmosphere
    float x_exit_atmo;   		// distance from the origin at which the ray exits the atmosphere

    float x_enter_world; 		// distance from the origin at which the ray strikes the surface of the world
    float x_exit_world;  		// distance from the origin at which the ray exits the world, assuming it could pass through

    // "atmosphere_radius" is the distance from the center of the world to the top of the atmosphere
    // NOTE: "12." is the number of scale heights needed to reach the official edge of space on Earth.
    // It should be sufficiently high to work for any world
    float atmosphere_radius = world_radius + 12. * atmosphere_scale_height;

    get_relation_between_ray_and_point(
		world_position, 
    	segment_origin,  segment_direction, 
		z2,			x_z 
	);
    try_get_relation_between_ray_and_sphere(
        world_radius,
        z2,            x_z,
        x_enter_world, x_exit_world 
    );

    bool is_obstructed = 
        0. < x_exit_world && x_exit_world < segment_length &&
        z2 < world_radius*world_radius;

    if (is_obstructed)
    {
    	return BIG;
    }

    try_get_relation_between_ray_and_sphere(
        atmosphere_radius,
        z2,            x_z, 
        x_enter_atmo,  x_exit_atmo
    );
    
    // NOTE: "sigma0" the column density ratio returned by approx_air_column_density_ratio_along_ray_for_absx() for the surface
    float sigma0 = approx_reference_air_column_density_ratio_along_ray(
    	x_exit_world-x_z, x_exit_atmo-x_z, 
    	z2, world_radius, atmosphere_scale_height
	);

    return approx_air_column_density_ratio_along_ray_2d( 
    	0.-x_z,           segment_length-x_z, 
    	x_exit_world-x_z, x_exit_atmo-x_z, sigma0, 
    	z2, world_radius, atmosphere_scale_height 
	);
}
