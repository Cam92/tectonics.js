// Optics is a namespace isolating all business logic relating to the transfer of radiation
// This was written so I could decouple academic concerns (like how to model something mathematically) from architectural concerns (like how a model is represented through classes)
// All functions within the namespace are static and have no side effects
// The only data structures allowed are rasters and grid objects

var Optics = (function() {
	var Optics = {};

	Optics.STEPHAN_BOLTZMANN_CONSTANT = 5.670373e-8; // W/m^2 per K^4

	// TODO: figure out where to put above function
	// maybe another namespace: "Heliosphere"? "StellarModeling"?

	// This calculates the radiation (in watts/m^2) that's emitted by the surface of an object.
	Optics.black_body_radiation = function(
			temperature,
			result
		) {
		result = result || Float32Raster(pos.grid);
		Float32Raster.fill(result, 1);
		ScalarField.mult_field	(result, 		temperature, 						result);
		ScalarField.mult_field	(result, 		temperature, 						result);
		ScalarField.mult_field	(result, 		temperature, 						result);
		ScalarField.mult_field	(result, 		temperature, 						result);
		ScalarField.mult_scalar	(result, 		Optics.STEPHAN_BOLTZMANN_CONSTANT, 	result);

		return result;
	}
	// This calculates the uniform (non-field) temperature of a body given its luminosity 
	// TODO: put this under a new namespace? "Thermodynamics"? 
	Optics.black_body_equilibrium_temperature_uniform = function(heat) { 
		return Math.pow(heat / Optics.STEPHAN_BOLTZMANN_CONSTANT, 1/4); 
	} 
	// This calculates the temperature of a body given its luminosity
	// TODO: put this under a new namespace? "Thermodynamics"?
	Optics.black_body_equilibrium_temperature = function(
			luminosity,
			result,
			greenhouse_gas_factor
		) {
		greenhouse_gas_factor = greenhouse_gas_factor || 1.3;
		result = result || Float32Raster(luminosity.grid);
		ScalarField.mult_scalar	(luminosity, 	greenhouse_gas_factor / Optics.STEPHAN_BOLTZMANN_CONSTANT, 	result);
		ScalarField.pow_scalar	(result, 		1/4, 														result);

		return result;
	}
	
	// This calculates the intensity of incident radiation (in Watts/m^2) 
	// that's felt on the surface of an object from a circular light source 
	// The function considers the following:
	//  * the distance to the light (the "Inverse Square Law")
	//  * the occlusion of light by the object itself
	//  * the angle at which the light hits ("Lambert's Law")
	Optics.incident_radiation = function(
			// This is a vector raster indicating the surface normal of an object
			surface_normal,
			// This is a vector indicating the light's offset from the object
			light_offset, 
			// total power output of light source in all directions, in Watts
			luminosity,
			// Float32Raster that stores results
			result
		) {
		result = result || Float32Raster(surface_normal.grid);

		// use cosine similarity to find cosine of light's zenith angle
		VectorField.vector_similarity 	(surface_normal, light_offset, 	result);

		// obscure light where it is occluded by the object
		Float32RasterInterpolation.clamp(result, 0, 1, 										result);

		// intensity of stellar insolation, in Watts/m^2
		// this is the power generated by a 100% efficient, 1 m^2 solar panel that's directly facing the sun
		var light_distance = Vector.magnitude(
			light_offset.x,
			light_offset.y,
			light_offset.z
		);
		// intensity of stellar insolation, in Watts/m^2
		// this is the power generated by a 100% efficient, 1 m^2 solar panel that's directly facing the sun
		var intensity = luminosity / ( 4 * Math.PI * light_distance * light_distance );

		ScalarField.mult_scalar			( result, intensity, 					result );

		return result;
	}


	return Optics;
})();
