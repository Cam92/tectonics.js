
#include "xtensor/xarray.hpp"

#include <emscripten/bind.h>

using namespace emscripten;

// Template classes will not be generated by the compiler unless they're used,
// but we will only use them interactively, after compilation has completed.
// So we must declare them explicitly here, instead.
template class xt::xarray_container<xt::svector<float>, xt::layout_type::row_major, xt::dynamic_shape<float> >;
template class xt::xcontainer<xt::xarray_container<xt::svector<float>, xt::layout_type::row_major, xt::dynamic_shape<float> >>;

template<typename T>
void to_typed_array(xt::xarray<T>& out, const val& typed_array)
{
  unsigned int typed_array_length = typed_array["length"].as<unsigned int>();
  //TODO: verify output length equals typed_array length

  val memory = val::module_property("buffer");
  val memoryView = typed_array["constructor"].new_(memory, reinterpret_cast<uintptr_t>(out.data()), typed_array_length);
  memoryView.call<void>("set", typed_array);
}

template<typename T>
xt::xarray<T> from_typed_array(const val& typed_array)
{
  unsigned int typed_array_length = typed_array["length"].as<unsigned int>();
  xt::xarray<T> out = xt::xarray<T>(typed_array_length);
  to_typed_array(out, typed_array);
  return out;
}

template<typename T>
void to_list(xt::xarray<T>& out, const val& list)
{
  unsigned int list_length = list["length"].as<unsigned int>();
  //TODO: verify output length equals list length

  for (unsigned int i = 0; i < list_length; ++i)
  {
    out[i] = list[i].as<T>();
  }
}

template<typename T>
xt::xarray<T> from_list(const val& list)
{
  unsigned int list_length = list["length"].as<unsigned int>();
  xt::xarray<T> out = xt::xarray<T>(list_length);
  to_list(out, list);
  return out;
}

EMSCRIPTEN_BINDINGS(rasters)
{
  enum_<xt::layout_type>("layout_type")
      .value("dynamic",      xt::layout_type::dynamic      )
      .value("any",          xt::layout_type::any          )
      .value("row_major",    xt::layout_type::row_major    )
      .value("column_major", xt::layout_type::column_major )
  ;

  value_array<xt::dynamic_shape<unsigned long>>("dynamic_shape_float")
      .element(index<0>())
      .element(index<1>())
  ;

  // class_<xt::xcontainer<xt::xarray<float>>>("fxcontainer")
  //     .function("size", &xt::xcontainer<xt::xarray<float>>::size)
  // ;

  class_<xt::xarray<float>, base<xt::xcontainer<xt::xarray<float>>>>("fxarray")
      .constructor<>()
      .constructor<const xt::dynamic_shape<unsigned long>&>()
      .constructor<const xt::dynamic_shape<unsigned long>&, float>()
      .constructor<const xt::dynamic_shape<unsigned long>&, float, xt::layout_type>()
  ;

  function("fxarray_to_typed_array",   (void (*)(xt::xarray<float>& out, const val& js_list )) to_typed_array   );
  function("fxarray_to_list",          (void (*)(xt::xarray<float>& out, const val& js_list )) to_list          );
  function("fxarray_from_typed_array", (xt::xarray<float> (*)(const val& js_list ))            from_typed_array );
  function("fxarray_from_list",        (xt::xarray<float> (*)(const val& js_list ))            from_list        );
}
